# Intro

Growing Object Oriented Software Guided by Tests is the overlap of two subjects. First, it assumes an awareness of OO. Second, it touts the other discipline of testing, or TDD. Although the book has ‘OO’ in the title, this is really a book about testing.

I was recommended this book by Sandi Metz during MetzFest. Sandi says Testing is the _Back against your wall_ when it comes to refactoring toward OO. As such, testing is not an option but a requirement for OO.

Over the past few weeks I’ve heard Ben Orenstein, Justin Searls, and [dude from github] all recommend this book. It seems this book has really impacted the people I look up to!

The more I learn about testing, the more I see that there isn’t really an alternative. There is no competing philosophy that says ‘No, don’t test your software, do _this thing instead_’. Choosing between testing and not testing is not like choosing between JS frameworks.  

What I’m learning is the different ways in which people choose to test their software. There are tests at different levels, different languages, different views, and different ways. It’s a matter. 

I like what Justin Searls has done by creating a testing wiki. He has done a great job in [this video] explaining to predominant testing philosophies. (Detroit vs. London) GOOS is London.

What I am getting at is, I’m starting to want to test my code. I’m seeing it as a requirement on the job and something where I initiate it, rather than dreading writing tests. I see how many benefits it has that I can safely begin to start a new feature with an investigation of the specs. I am now aware that an understanding of the spec suite will tell me about the application it is testing. 

What I really like about Testing is that it is a school of thought that is built on top of the software I write. Meaning, just because I can write software anyway I feel like it, doesn’t mean that is the wise and right thing to do. Testing ensures the code I write is written in a way that can be changed. Of course, that’s not entirely true. I can (and will) write bad tests. My job is to learn how to write fast and durable tests. 



